Intent
    別アプリからのアクションリクエストで使用するメッセージングオブジェクト
    基本的な使い方
        1．アクティビティの開始
            StartAcitvityを使用して別アクティビティを開始するときにIntentの中に必要なデータを詰めて渡す
            Activityの完了時に結果を受け取るには、StartActivityForResultを使ってActivityを呼び出す
            受け取り側のアクティビティは、別のIntentをonActivityResult()のコールバックとして受け取る

        2．サービスの開始
            Serviceでも、Intentを渡すことで実行に必要なデータを渡すことができる
            1度きりの処理では、StartService()に渡すことでできる

        3．ブロードキャストの配信
            IntentをsendBroadcast(),sendOrderedBroadcast()に渡すことでアプリの受け取るメッセージに情報を載せられる

    インテントのタイプ
        明示的インテント
            コンポーネントの名前を指定して起動すること
            アプリ内で新しいアプリを起動したり、ファイルダウンロードをするサービスを起動したりできる

        暗黙的インテント
            特定のコンポーネントを指定せず、代わりに、実行する全般的な動作を指定して他アプリが処理できるようにする
            暗黙的インテントを使用したときは、AndroidOSがインテントの内容を他アプリのマニフェストに書かれたインテントフィルタの
            内容と比較をすることで開始するコンポーネントを見つける
            端末上のどのアプリでも実行できるアクションを指定する
            暗黙的インテントでは地震のアプリが実行することはできないが他のアプリは処理ができるときなどに便利
            複数アプリのインテントフィルタが競合するときはユーザーが使うアプリを指定できるようにダイアログの表示がされる
            * インテントフィルタ
                コンポーネントが受け取りたいインテントのタイプを指定する式のこと
                アクティビティのインテントフィルタを指定すると特定のインテントタイプを持つActivityを他のアプリから起動できるようになる
                宣言をしないときは明示的インテントのみで起動できるコンポーネントになる
            ※注意点
                Serviceの起動には必ず明示的インテントを使用する
                Android5.0以降では、暗黙的インテントを使用してbindServiceを呼ぶと例外になる

            暗黙的インテントを受け取るには
                ・アプリが暗黙的インテントを受け取れるようにするには,manifestファイルで<intent-filter>要素を使って
                　アプリのコンポーネントごとに1つ以上のインテントフィルタを宣言する
                ・インテントのアクション、データ、カテゴリに基づいて受け入れるインテントのタイプを指定し、
                　いずれかのフィルタを通過したときにシステムが暗黙的インテントをコンポーネントに配信する
                ・android:exportedを指定することでアプリコンポーネントにほかのアプリがアクセスできるようになった

    intentの要素
        コンポーネント名
            開始するコンポーネントの名前
            暗黙的インテントの場合は不要になるが、明示的インテントを使用するときには不可欠となる要素
            Serviceを開始するときには常にコンポーネント名を指定する必要がある
        アクション
            実行する操作を指定する文字列
            ブロードキャストインテントの場合ほとんどのインテントがどのように構成されているかで決まる
            独自アクションの指定などもできる
        データ
            アクション実行対象のデータや、データのMIMEタイプを指定するURL
            提供されるデータタイプはインテントのアクションによってきまる
        カテゴリ
            インテントを処理するコンポーネントの追加情報の含まれたものインテントにいくつでも追加できる
            カテゴリはAddCategory（）で追加できる
        Extra
            要求されたアクションの実行に必要な追加情報のキーとバリューのペア1部アクションは、特定エクストラも使用する
            putExtraを使うことでインテントに追加できる
            Bundleオブジェクトとしてまとめて追加してからもOK
        フラグ
            Activityの起動方法や起動後の取り扱いを指定できる
Activity　
    概要
        アプリがユーザーとやり取りをするためのエンドポイントとして機能する
        アクティビティを宣言するにはマニフェストファイルにactivityの用を追加する必要がある
    ライフサイクル
        onCreate()
            アクティビティが最初に作成したときに呼ばれる
            コンポーネントの初期化をする
            アクティビティが存続している間に一回だけ呼び出される
            setContentView()などを呼び出し、ここでビューを作成する
            ViewModelやデータをリストにバインドする

        onStart()
            アクティビティが開始状態になると呼び出される
            アクティビティがユーザーに表示され、ユーザーとの対話ができるようになるための最終準備が行われる

        onResume()
            アクティビティがユーザーと対話をするときに呼ばれる。
            何かユーザーからアクションがあるまではこの状態にいる
            ユーザー入力のすべてをここで行うため、アプリの機能はここで実装する

        onPause()
            アクティビティがフォーカスを失うとシステムが呼ぶ。
            ユーザーがアクティビティから離脱したときに呼ぶ
            アクティビティの破棄ではなく、フォアグラウンドにないだけ
            一部表示されている間などもここになる（ダイアログの裏とか）
            DB処理などは記述をしないことが推奨
                このライフサイクル自体がみじかくなるため

        onStop()
            呼ばれると、アクティビティがユーザーに表示されなくなる
            次の新しいアクティビティとかが表示された時に呼ばれる
            シャットダウン処理などDB操作もOK
            この次にくるライフサイクルはonRestart()もしくはonDestroy()

        onRestart()
            アクティビティが停止した時点の状態を復元する

        onDestroy()
            アクティビティが破棄される前に呼ばれる
            アクティビティが完全終了しているかfinish()が呼び出される時に呼ばれる
            設定の更新や、デバイスの回転などによりシステムが一時的にアクティビティを破棄したとき
            すべてのリソースを開放する処理などを記述する
            Activityが再生成されない場合、対応しているViewModelではonCleard()が呼び出されて、破棄する前に必要なデータをクリーンアップできる
    アクティビティの状態とメモリからの退避
        RAMを開放する必要があるときにシステムはプロセスを強制終了する
        プロセスを強制終了するかどうかは、その時点で実行されているアクティビティによって変わる
        システムがメモリを解放するためにアクティビティを直接強制終了することはない
        代わりにアクティビティを実行しているプロセス自体を終了する

        状態
        ・フォアグラウンド(Resumed)
            確率は最低
        ・フォーカスされていない(Started/Paused)
            確率は低め
        ・バックグラウンド(Stopped)
            確率は高め
        ・なし(Destroyed)
            ほぼ確定
Service
    概要
        アプリケーションのバックグラウンドで動作するコンポーネント
        マニフェストでSerVice要素を追加しないといけない
        UIを持たずにアクティビティとは独立して動作する
        ユーザーの直接操作しないタスクの実行に使う
            音楽再生、ファイルアップロード、位置情報の取得、データの同期
        Android8.0以降はバックグラウンド制限の影響でサービスを使う場面が減った
            Foreground ServiceとWorkManagerの適切な組み合わせで解決していく

    種類
        Foreground Service
            ユーザーに認識された状態で実行されるサービス
            電力消費などが大きいため、必要のない時は速やかに終了するようにする必要がある
            優先度が高く、中止や停止が回避される
            通知をユーザーに送ったりする必要がある
                進行状況や、状態
            バックグラウンド制限を受けず、常時動作や、リアルタイム性が求められる処理に最適
                音楽アプリや動画のバックグラウンド処理
                位置情報の追跡などのトラッキング
            記述の仕方
                NotificationCompat.Builder()で通知を作成して、
                サービスのOnStartCommand()内でstartForeground()を使ってフォアグラウンドサービスとして呼び出す
                stopSelf(),StopService()をすることで停止を行う

        Background Service
            ユーザーに認識されない状態で実行されるサービス
            アプリ自体がフォアグラウンドにない時にも動作するが、Android8.0以降は制限が強化されている
            WorkManagerとは違い、タスクの完了が保証されない
            一時的な処理に使用することはできる
            長時間の処理や、システムリソースを効率化したい処理などにはWorkManagerを使うべき

        Bound Service
            BindService()を実行してバインドをするとサービスとコンポーネントの間でプロセス間通信(IPC)ができる
            AIDLを使用したメッセージ交換などがある
            多対1でバインドができ、すべてのコンポーネントからバインドが解除(unbindService)されるとシステムがサービスを自動で破棄する

    開始する方法の違い
        startService()
            別のコンポーネントからstartService()を呼び出すとサービスが作成される。
            開始されたサービスは明示的に自身で停止`stopSelf()`または他コンポーネントから`StopService()`しないと終わらない
            startService()を呼ぶとサービスのonStartCommand()が呼び出される
        サービスは呼ばれたときに呼び出し元のコンポーネントとは別のライフサイクルで実行されるため、呼び出し元が終了しても続くので注意
            サービスが完了したときにはstopSelf()を呼び出すか、別のコンポーネントがtopService()を呼び出して破棄するしかない
        onstartCommand()でアクティビティから投げられたIntentを受け取ることができる
        Serviceクラスを継承しIntentServiceクラスもあるが、バックグラウンドサービスの制限からAndroid11以降はJobIntentServiceを使用するべき
        作成された時点では、デフォルトでアプリのメインスレッド内で宣言されるため、アプリへの影響を避けるために新しいスレッドを開始する

        BindService()
            別コンポーネントが`bideService()`を呼び出すことで開始される
                通常はstartService()を呼び出して起動することはできない
            onBind()を実装し、通信用インターフェイスであるIBinderインターフェイスを返す
            アクティビティとサービスのやり取りを行う時はプロセス間通信(IPC)を介してほかのアプリと通信ができる
            作成時には、クライアントとサービスの通信方法を指定するインターフェイスを定義する必要がある（IBinderインターフェイスの実装）
            複数クライアントから同じサービスをバインドすることができて、すべてが解除されるとシステムが勝手にサービスを破棄してくれる
            別コンポーネントはいつでもunbindService()を呼び出すことでバインドは解除される

    サービスの使い方
        マニフェストでの宣言が必要

    ユーザーへの通知
        サービスが実行されているときにイベントを通知するには、スナックバー通知またはステータスバー通知を使用する
            スナックバー通知
                ウインドウの表面に一瞬だけ表示される
            ステータスバー通知
                ステータスバーにアイコン表示を行いメッセージを表示する

    ライフサイクル
        二つの経路を通る
        onCreate()
        onStartCommand()
        onBind()
        onUnBind()
        onReBind()
        onDestroy()



Facadeパターン
    ごちゃごちゃなクラス間の関係した処理を一つの単純なインターフェイスで使うことができるパターン
    メリット
        複雑な処理からほかのクラスを分けることができる
    デメリット
        Facadeクラス自体が紙オブジェクトになっていしまう可能性がある

WorkManagerのテストには
    TestListenableWorkerBuilderを使える
    MockWebserver
    TestListenableWorkerBuilder
    Gson